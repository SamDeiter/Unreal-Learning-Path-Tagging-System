WEBVTT

1
00:00:00.000 --> 00:00:05.900
Next up, let's talk about the world partition tools that are available to you.

2
00:00:05.900 --> 00:00:12.020
So we have world partition and world partition is automatic data management and distance

3
00:00:12.020 --> 00:00:14.300
based level streaming as we mentioned at the start.

4
00:00:14.300 --> 00:00:20.260
So it's a system that provides a complete solution for large world management.

5
00:00:20.260 --> 00:00:25.060
The world partition system works by storing your world in a single persistent level file

6
00:00:25.060 --> 00:00:30.260
and then subdividing that space into a streamable grid like you can see here.

7
00:00:30.260 --> 00:00:37.620
And then the streamable grid cells use the configuration that you set on the runtime grid.

8
00:00:37.620 --> 00:00:41.860
So these cells are loaded and unloaded at runtime by the presence of the streaming source.

9
00:00:41.860 --> 00:00:45.380
As we mentioned before, the streaming source is going to be the player here.

10
00:00:45.380 --> 00:00:49.580
And in this way, Unreal Engine only loads the parts of the level that the player sees

11
00:00:49.580 --> 00:00:51.620
and interacts with at a given time.

12
00:00:51.620 --> 00:00:54.860
So it's really, really nice, powerful optimization tool here.

13
00:00:54.860 --> 00:00:57.260
We've got level instance in here.

14
00:00:57.260 --> 00:01:02.660
So level instances were originally created to replace Fortnite's foundations,

15
00:01:02.660 --> 00:01:08.700
allowing multiple instances of a level to be used in the world partition level and the classic.

16
00:01:08.700 --> 00:01:13.560
So we improve the overall level editing workflow experience here.

17
00:01:13.560 --> 00:01:15.500
So what are the features?

18
00:01:15.500 --> 00:01:19.760
So the features are nested in hierarchical level instances.

19
00:01:19.760 --> 00:01:28.300
We've got edit in context, which always is the original level, not a pair instance or data edit support.

20
00:01:28.300 --> 00:01:31.700
We can also have multiple instances within the same world.

21
00:01:31.700 --> 00:01:38.460
We've got an embedded mode, which is the default mode, and that's content pushed to the persistent world partition grid.

22
00:01:38.460 --> 00:01:42.760
And we've also got level streaming mode for non one file per actor levels.

23
00:01:42.760 --> 00:01:47.300
So if you do want to make use of level streaming, you can do that.

24
00:01:47.340 --> 00:01:55.300
But also, as we mentioned at the start, the one file per actor is a really great system for collaborative environments.

25
00:01:55.300 --> 00:02:01.640
Data layers on the level instance actor is also a good feature, and it's pushed to the entire content.

26
00:02:01.640 --> 00:02:03.540
So what are the use cases here?

27
00:02:03.540 --> 00:02:10.140
So we may do points of interest, we may do houses, standalone gameplay setups.

28
00:02:10.180 --> 00:02:21.080
And then also, when we're talking about a packed level actor, we generate a single optimized version for the render engine blueprint actor.

29
00:02:21.080 --> 00:02:24.380
So it supports only static mesh components.

30
00:02:24.380 --> 00:02:26.940
So this is a non destructive way.

31
00:02:26.940 --> 00:02:38.980
So if we are looking at the packed level actor, the features outputs a packed level actor blueprint, which with only static mesh from the content.

32
00:02:38.980 --> 00:02:44.880
We've got the feature that outputs a level that is linked to a packed level actor for non destructive editing.

33
00:02:44.880 --> 00:02:49.520
And then also you can have multiple instances like any other actor within the same world.

34
00:02:49.520 --> 00:02:52.460
And then the data layers are packed on the level actor only.

35
00:02:52.460 --> 00:02:54.820
So really, really cool features there.

36
00:02:54.820 --> 00:03:07.480
And then the use cases of the packed level actor might be static buildings in the city demo or very dense visual only setups with multiple instances of the same models.

37
00:03:07.520 --> 00:03:15.080
So as we've been alluding to the one file per actor is a really powerful tool to use in your projects in previous versions of Unreal.

38
00:03:15.080 --> 00:03:24.180
When you wanted to make changes to one or more actors inside a level, you needed to check out that entire level in source control, which meant multiple people couldn't work on it.

39
00:03:24.180 --> 00:03:28.320
So it locked the team members out of that file until the work was complete.

40
00:03:28.320 --> 00:03:32.580
It could then slow down the development process because only one person could work on that file.

41
00:03:32.620 --> 00:03:44.260
So one file per actor reduces overlap between users by saving data for instances of actors in external files, removing the need to save the main level when making changes to its actors.

42
00:03:44.260 --> 00:03:48.560
So one file per actor is enabled by default when using world partition.

43
00:03:48.560 --> 00:03:55.820
And the use of one file per actor outside of world partition is currently considered experimental and is disabled by default.

44
00:03:55.820 --> 00:04:01.120
So one file per actor feature is designed to be granular and can be used in two different ways.

45
00:04:01.120 --> 00:04:08.500
So first way, after selecting the option, you'll be asked if you want to enable the feature for all the actors in the level.

46
00:04:08.500 --> 00:04:15.360
Select yes to convert all the actors to one file per actor or no, which only enables it for the selected actor.

47
00:04:15.360 --> 00:04:23.420
So you can either say yes, I want to convert all actors to one file per actor or no, I only want to use it on this one actor that I have selected.

48
00:04:23.420 --> 00:04:29.560
So it's kind of opt in or opt in to everything per actor, which is a really cool tool there.

49
00:04:30.560 --> 00:04:33.100
We also got data layers inside of Unreal Engine.

50
00:04:33.100 --> 00:04:38.140
So data layers are a system within world partition used for organizing the actors into separate layers.

51
00:04:38.140 --> 00:04:42.060
So the layers can be loaded and unloaded to organize your world.

52
00:04:42.060 --> 00:04:47.500
So data layers serve as a replacement for previous layers found in older versions of Unreal.

53
00:04:47.500 --> 00:04:53.940
And with data layers, gameplay elements and environment assets can be separated in the editor at runtime.

54
00:04:53.940 --> 00:04:56.560
So if you're using data layers, what does that mean?

55
00:04:56.600 --> 00:04:59.860
How can we separate an editor and at runtime?

56
00:04:59.860 --> 00:05:06.140
So it means that artists can work on specific elements without interacting with gameplay triggers or objects.

57
00:05:06.140 --> 00:05:12.700
Designers can dynamically load layers to design intriguing gameplay and elaborate level transitions at runtime.

58
00:05:12.700 --> 00:05:16.700
This can be useful for gameplay purposes.

59
00:05:16.700 --> 00:05:21.000
Keeping with the world partition system's goal of minimizing file overlap between users,

60
00:05:21.040 --> 00:05:28.880
we can have data layers that reduce the need for users to check out important files such as world map file or actor files when making changes.

61
00:05:28.880 --> 00:05:34.500
Each data layer has a display label and an internal unique identifier.

62
00:05:34.500 --> 00:05:44.100
And then Unreal stores the information in a list of data layers in the world data layer file, which provides some of the benefits that I'm going to go into.

63
00:05:44.140 --> 00:05:57.440
So three benefits here of world data layer is assigning data layers to an actor only affects the actor's file in world partition, which uses the one file per actor.

64
00:05:57.440 --> 00:06:03.200
We can also rename a data layer to have it only affect the associated level.

65
00:06:03.200 --> 00:06:08.700
So then there'd be no need to update any actors associated with that layer.

66
00:06:08.700 --> 00:06:13.100
You can also delete the data layer, which only affects the world data layer file.

67
00:06:13.100 --> 00:06:21.500
So actors previously associated with the data layer are automatically cleaned up with no need to modify or save the actor.

68
00:06:21.500 --> 00:06:27.340
So data layers states can also be changed via blueprints.

69
00:06:27.340 --> 00:06:32.080
Next, looking at the hierarchical level of detail, which is the HLOD.

70
00:06:32.080 --> 00:06:39.640
This system uses HLOD layers to organize large amounts of static mesh actors to generate a single proxy mesh and material.

71
00:06:39.680 --> 00:06:47.080
So this technique is used to visualize unloaded world partition grid cells to reduce the number of draw calls per frame.

72
00:06:47.080 --> 00:06:51.940
And it also increases performance, especially when you have these large open worlds.

73
00:06:51.940 --> 00:06:59.420
So you can create a HLOD layer by right clicking in the content browser and going to miscellaneous HLOD layer.

74
00:06:59.420 --> 00:07:02.940
And then you can have various HLOD layers that are used throughout your entire project.

75
00:07:02.980 --> 00:07:11.080
So the settings on the HLOD are instancing, merged mesh, simplified mesh and approximated mesh.

76
00:07:11.080 --> 00:07:17.640
So with the instancing, which is the first option, the layer is composed of an instant static mesh.

77
00:07:17.640 --> 00:07:24.580
So you might say ISM for instant static mesh and their components used with the lowest level of detail meshes.

78
00:07:24.580 --> 00:07:37.180
So if you're using instancing, that's ideal for imposters, for example, trees ought to replicate the source actors geometry whilst dropping non-visual data.

79
00:07:37.180 --> 00:07:43.220
Merged mesh, meshes included in this layer are merged to create a single mesh.

80
00:07:43.220 --> 00:07:52.380
Simplified mesh, where mesh is included in that layer, are merged and the mesh is simplified for performance.

81
00:07:52.380 --> 00:08:05.720
And then the approximated mesh is similar to simplified mesh, but it uses a newly developed algorithm that performs much better on complex scenes, which contains many instances on nano enabled static meshes.

82
00:08:05.720 --> 00:08:13.060
So to see the changes, you'll need to go to the build menu at the top of your editor and select the build HLOD option.

83
00:08:13.060 --> 00:08:17.520
And then the system will only build LODs that are needed to be rebuilt.

84
00:08:17.560 --> 00:08:24.660
So this can be done from a command line as well, so that it can be run during nightly builds as well.

85
00:08:24.660 --> 00:08:31.960
Looking at the virtual textures, and so virtual texturing is needed for the minimap generation, like we said at the start.

86
00:08:31.960 --> 00:08:38.260
So while it's not required for open world tools to work, it does help and should be used whenever possible.

87
00:08:38.260 --> 00:08:41.560
So Unreal Engine supports two virtual texturing methods.

88
00:08:41.560 --> 00:08:51.160
We've got the runtime virtual texturing, which you'll sometimes see as RVT, runtime virtual texturing and streaming virtual texturing SVT.

89
00:08:51.160 --> 00:08:58.200
So runtime virtual textures are used for procedurally generated content and heavy layered materials.

90
00:08:58.200 --> 00:09:01.000
Supports larger texture resolutions.

91
00:09:01.000 --> 00:09:04.360
The textual data cached in memory on demand.

92
00:09:04.360 --> 00:09:11.400
Textual data is generated by the GPU at runtime and it's well suited for textual data that can be rendered on demand.

93
00:09:11.400 --> 00:09:15.400
Such as procedural textures or composite layer materials.

94
00:09:15.400 --> 00:09:24.980
So the streaming virtual textures are used for reducing texture memory overhead when using larger texture sizes for items like lightmaps.

95
00:09:24.980 --> 00:09:28.040
So it supports larger texture resolutions.

96
00:09:28.040 --> 00:09:31.280
Textual data is cached in memory on demand.

97
00:09:31.280 --> 00:09:35.800
Textual data is cooked and loaded from disk and that's well suited.

98
00:09:35.840 --> 00:09:46.400
So streaming virtual textures are well suited for textual data that takes time to generate, such as lightmaps or large detailed artist created textures.

99
00:09:46.400 --> 00:10:00.180
So using virtual shadow maps, which you'll sometimes heard as referred to as VSMs, is a new shadow mapping method used to deliver consistent high resolution shadowing that works with film quality assets and large dynamically lit open world.

100
00:10:00.180 --> 00:10:04.820
So VSMs are built to work seamlessly in Unreal Engine.

101
00:10:04.820 --> 00:10:15.220
And we can use the Nanite virtualized geometry, the Lumen global illumination reflections and also world partition features with virtual shadows.

102
00:10:15.220 --> 00:10:27.620
And lastly, we have Nanite. So Nanite is Unreal Engine 5's virtualized geometry system, which uses the new internal mesh format and rendering technology to render pixel scale detail and high object counts.

103
00:10:27.660 --> 00:10:32.660
And it intelligently does work on only the detail that can be received and no more.

104
00:10:32.660 --> 00:10:36.220
So only what the viewer can see, it'll work on that.

105
00:10:36.220 --> 00:10:43.580
So Nanite's data format is highly compressed and supports fine grained streaming with automatic level of detail.

106
00:10:43.580 --> 00:10:46.900
So Nanite should generally be enabled whenever possible.

107
00:10:46.900 --> 00:10:54.060
So any static mesh that has it enabled will typically render faster and take up less memory and also disk space.
