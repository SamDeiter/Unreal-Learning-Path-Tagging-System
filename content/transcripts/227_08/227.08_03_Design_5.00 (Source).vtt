WEBVTT

1
00:00:00.000 --> 00:00:06.040
Next, let's talk about how we might approach the design of our project today.

2
00:00:06.040 --> 00:00:11.200
So we can start off by looking at UMG, which is Unreal Engine's motion graphic system.

3
00:00:11.200 --> 00:00:14.600
It's a 2D slash 3D user interface designer.

4
00:00:14.600 --> 00:00:19.200
You can mock up UI directly inside of Unreal Engine.

5
00:00:19.200 --> 00:00:24.480
All of this content, maybe except this icon here was created inside of Unreal Engine.

6
00:00:24.480 --> 00:00:26.140
So you can draw text.

7
00:00:26.140 --> 00:00:27.600
You can have slider bars.

8
00:00:27.600 --> 00:00:30.360
You can have little pop out buttons.

9
00:00:30.360 --> 00:00:32.400
It's very modular in nature.

10
00:00:32.400 --> 00:00:40.080
And it's very useful to begin prototyping any kind of content you might need for your projects.

11
00:00:40.080 --> 00:00:47.240
When we talk about touch screens, we want to make sure the icons are nice and large in our projects.

12
00:00:47.240 --> 00:00:51.280
We want to assume that the user is distracted.

13
00:00:51.280 --> 00:00:52.760
The roads are bumpy.

14
00:00:52.760 --> 00:00:54.720
Consider spacing out UI elements.

15
00:00:54.720 --> 00:01:03.000
So making sure we're considering the borders and the grids and just making sure the overall interface is nice and straightforward to use.

16
00:01:03.000 --> 00:01:08.120
We, of course, want to make sure accessibility is kept in mind at all times.

17
00:01:08.120 --> 00:01:21.000
So any kind of high contrast modes, colorblind modes, any kind of outline on text that will support the user is really useful to consider at this stage.

18
00:01:21.000 --> 00:01:27.120
When we display data management, we can think about widgets as templates.

19
00:01:27.120 --> 00:01:36.400
When you're thinking about child widgets, we can create elements with default value from a custom class.

20
00:01:36.400 --> 00:01:46.840
So essentially, if you're going to be reusing a lot of information and you don't want to keep making the same UI element again and again,

21
00:01:46.840 --> 00:01:52.160
we can have a parent widget that holds all the main information.

22
00:01:52.160 --> 00:01:59.720
And then what we can do is we can create a child widget from that parent widget and it can consume the data from the parent.

23
00:01:59.720 --> 00:02:07.640
But then you can also override specific variables or options that you want to kind of customize to this child class.

24
00:02:07.640 --> 00:02:10.280
And it's just a much cleaner way to work.

25
00:02:10.280 --> 00:02:15.880
It means that if you want to change any of the larger structure, you can do so in the parent class.

26
00:02:15.880 --> 00:02:22.400
And then the child class, even if the child class was made after the fact, it will still inherit those new properties.

27
00:02:22.400 --> 00:02:30.440
So if you have to make a change, you only make the change once in the parent class and then it deploys across all the child classes as well.

28
00:02:30.440 --> 00:02:35.160
So it can also prevent larger bugs and issues and things like this.

29
00:02:35.160 --> 00:02:41.920
We have slate brushes, which are reusable brush strokes as well that we can be used in inside of Unreal Engine.

30
00:02:41.960 --> 00:02:47.320
And also, as we mentioned on the previous slide, the text displays any kind of text you want.

31
00:02:47.320 --> 00:02:54.000
Say you want the vehicle speed displaying and we want to update the speed at runtime.

32
00:02:54.000 --> 00:03:00.360
We can bind specific elements of text and we can also format that text all at runtime.

33
00:03:00.360 --> 00:03:04.960
So if values are changing, we can do this inside of UNG.

34
00:03:05.000 --> 00:03:15.080
We also have rich text, which the rich text block uses a data table asset to manage the styles and the customization of your projects.

35
00:03:15.080 --> 00:03:19.240
We can also embed video into our UI projects here.

36
00:03:19.240 --> 00:03:22.520
So we use the media framework in this instance.

37
00:03:22.520 --> 00:03:28.080
So you can just right click anywhere in your content browser, go to the media option.

38
00:03:28.080 --> 00:03:33.960
And on the media section, you can go to the file media source here.

39
00:03:33.960 --> 00:03:38.160
We've got the media textures, media player and the playlist.

40
00:03:38.160 --> 00:03:46.880
If you want to get more information about how to use video inside your projects, there's a really good Unreal Engine documentation page,

41
00:03:46.880 --> 00:03:56.800
which if you just type in Unreal Engine docs media framework, it'll come up for you and a very straightforward process.

42
00:03:56.800 --> 00:04:01.720
But it's more of a step by step how to on how to get videos inside your project.

43
00:04:01.720 --> 00:04:07.920
So the really useful thing about the video is it can be rendered either in 2D or 3D.

44
00:04:07.920 --> 00:04:16.120
So you can see in the screenshot, we've actually placed a plane in the world, which we can use to project the video.

45
00:04:16.120 --> 00:04:22.240
So it can either be overlaid on the screen in 2D or it can be projected in the world as 3D.

46
00:04:22.240 --> 00:04:27.120
And all videos are in your content folder and in movies.

47
00:04:27.160 --> 00:04:34.520
So when you have your projects and you have a content folder with the various blueprints and assets that you've created,

48
00:04:34.520 --> 00:04:43.760
we just want to create a movies folder there to store all of our raw movies, which Unreal Engine then streams from that movie content folder.

49
00:04:43.760 --> 00:04:50.440
And when we're looking at performance interfaces, material complexity can be a useful thing to highlight here.

50
00:04:50.440 --> 00:04:53.560
It can increase the pixel cost of a render.

51
00:04:53.560 --> 00:05:00.880
So the more instructions there are for each pixel, the more time the render needs to spend calculating its final value.

52
00:05:00.880 --> 00:05:10.040
So opaque materials on a UI, the least expensive, but can differ greatly based on the shading model or the base shader code.

53
00:05:10.040 --> 00:05:17.040
So if you're wanting any slightly transparent buttons, just know that it can come with a cost.

54
00:05:17.040 --> 00:05:20.840
So we can find more information.

55
00:05:20.880 --> 00:05:25.520
Again, documentation is a really good resource to start digging into.

56
00:05:25.520 --> 00:05:32.760
So you can look at the testing and optimization documentation to find more information about this.

57
00:05:32.760 --> 00:05:42.000
And then there's also a documentation page on interactive experiences, which is a really good user best practice guide.

58
00:05:42.000 --> 00:05:47.200
So we can talk about performance in relation to project specific outcome.

59
00:05:47.240 --> 00:05:54.320
You just want to be thinking about that early on, making sure you get all your UI elements on the screen.

60
00:05:54.320 --> 00:06:02.840
If you're wanting to store any data from this UI, you can use the game instance, which means there's less loading and unloading.

61
00:06:02.840 --> 00:06:09.240
As we were talking about before, if there's any kind of permanent storing and data, you want to use the game instance there.

62
00:06:09.240 --> 00:06:17.920
And we also have UMG tools built into the editor, which we have widget switches and user created widget components,

63
00:06:17.920 --> 00:06:25.880
which allows you to interact with any other custom components or between multiple widgets at the same time.

64
00:06:25.880 --> 00:06:30.640
Say you want to toggle through multiple screens or anything like this.

65
00:06:30.640 --> 00:06:33.320
We have that functionality inside the engine.
