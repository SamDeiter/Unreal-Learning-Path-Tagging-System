WEBVTT

1
00:00:00.000 --> 00:00:08.980
Next, let's go over the types of blueprints you may expect to see inside of Unreal.

2
00:00:08.980 --> 00:00:10.800
So there are several types of blueprints.

3
00:00:10.800 --> 00:00:13.900
You've got the level blueprint, which we referred to before.

4
00:00:13.900 --> 00:00:18.640
We've got blueprint classes, which are almost like a modular way to start building out your

5
00:00:18.640 --> 00:00:19.640
code.

6
00:00:19.640 --> 00:00:24.280
If you put it into a blueprint class, it means you can use it in many different areas, whereas

7
00:00:24.280 --> 00:00:29.000
a level blueprint is very specific to that one level that you're working on.

8
00:00:29.000 --> 00:00:30.800
You have data only blueprints.

9
00:00:30.800 --> 00:00:36.040
Say you want to store some data, but you don't necessarily need the interactivity behind

10
00:00:36.040 --> 00:00:37.040
it.

11
00:00:37.040 --> 00:00:38.360
You can get that data only blueprint.

12
00:00:38.360 --> 00:00:42.680
You have blueprint interfaces, which we briefly touched on a couple of minutes ago, but a

13
00:00:42.680 --> 00:00:47.840
blueprint interface essentially allows you to communicate from one blueprint to another.

14
00:00:47.840 --> 00:00:53.760
You've got blueprint macros, which is almost like a wrapper for some scripting that you

15
00:00:53.760 --> 00:00:56.020
might have inside of a blueprint.

16
00:00:56.020 --> 00:01:01.800
So a macro can be repurposed in multiple blueprints if you wanted to.

17
00:01:01.800 --> 00:01:06.500
The way to think about macros over functions, because functions and macros can be similar.

18
00:01:06.500 --> 00:01:09.400
You might see those terms quite frequently.

19
00:01:09.400 --> 00:01:13.900
Macros can actually house latent functionality.

20
00:01:13.900 --> 00:01:18.900
So what I mean by that is if you wanted to create this bit of code that you want to reuse

21
00:01:18.900 --> 00:01:22.380
in multiple places, it may have some kind of delay.

22
00:01:22.540 --> 00:01:30.620
You may have an event fire, say an explosion goes off and you want to wait five seconds

23
00:01:30.620 --> 00:01:34.660
and trigger a vehicle moving across the scene.

24
00:01:34.660 --> 00:01:38.740
That can be stored in a macro because it has latent functionality.

25
00:01:38.740 --> 00:01:43.340
It has a delay in there, whereas a function would not be able to house a delay.

26
00:01:43.340 --> 00:01:50.640
A function has to fire through and process the code, but it can't wait for any kind

27
00:01:50.640 --> 00:01:53.120
of dependency on the functionality.

28
00:01:53.120 --> 00:01:56.760
So hopefully that does give you a bit of context over what macros might be.

29
00:01:56.760 --> 00:02:01.280
And then you've got animation blueprints, which again, very visual driven and it's

30
00:02:01.280 --> 00:02:03.760
almost like a state machine setup.

31
00:02:03.760 --> 00:02:08.560
And you can even communicate with animation blueprints into your level blueprint or another

32
00:02:08.560 --> 00:02:10.040
blueprint class.

33
00:02:10.040 --> 00:02:15.080
Say you want to trigger some certain code on maybe a character that's moving around

34
00:02:15.080 --> 00:02:16.200
the scene.

35
00:02:16.200 --> 00:02:18.400
You can do that through animation blueprints as well.

36
00:02:18.400 --> 00:02:23.720
So level blueprints and blueprint classes are what you're going to be using most commonly.

37
00:02:23.720 --> 00:02:25.240
So they're the top two examples.

38
00:02:25.240 --> 00:02:30.280
So again, level blueprint is very context specific to that level.

39
00:02:30.280 --> 00:02:35.440
So if you've got very specific functionality that's going on in that level, you can house

40
00:02:35.440 --> 00:02:37.020
that in the level blueprint.

41
00:02:37.020 --> 00:02:41.640
The way I like to think about it though, is if you're maybe making, again, going back

42
00:02:41.640 --> 00:02:46.720
to this vehicle moving across the scene or a door opening and closing, if you're going

43
00:02:46.760 --> 00:02:52.480
to reuse that door opening and closing across many different levels, you probably want to

44
00:02:52.480 --> 00:02:57.560
make a blueprint class for it because otherwise you'd have to keep remaking it every time

45
00:02:57.560 --> 00:02:59.000
on the level blueprint.

46
00:02:59.000 --> 00:03:03.760
Whereas a blueprint class, you make it once and then you can use it multiple times.

47
00:03:03.760 --> 00:03:08.800
So a level blueprint provides a control mechanism for level streaming, binding events to actors

48
00:03:08.800 --> 00:03:09.920
placed in the level.

49
00:03:09.920 --> 00:03:15.760
So again, we're doing some scripting that's very context specific to this level.

50
00:03:15.800 --> 00:03:21.280
So it's a specialized type of blueprint that acts as level wide global event graph.

51
00:03:21.280 --> 00:03:26.200
Each level in your project has its own level blueprint created and is there by default

52
00:03:26.200 --> 00:03:28.460
and it's automatically saved when the level saves.

53
00:03:28.460 --> 00:03:33.480
So when you go to file save all, the level blueprint will remember all the data.

54
00:03:33.480 --> 00:03:38.560
And again, just as a reminder, you can click on the blueprint window here in your editor

55
00:03:38.560 --> 00:03:41.900
and go to open level blueprint.

56
00:03:41.900 --> 00:03:45.960
Blueprint classes on the other hand, often just referred to as blueprints.

57
00:03:45.960 --> 00:03:49.060
When you hear people talking about using Unreal and blueprints, this is what they're referring

58
00:03:49.060 --> 00:03:50.060
to.

59
00:03:50.060 --> 00:03:55.220
So a blueprint class is an asset that allows content creators to easily add functionality

60
00:03:55.220 --> 00:03:58.040
on top of existing gameplay classes.

61
00:03:58.040 --> 00:04:04.000
So blueprints are essentially a defined new type of class or actor that can then be placed

62
00:04:04.000 --> 00:04:05.000
into different maps.

63
00:04:05.000 --> 00:04:09.800
So there's a door here, for example, that door can be its own blueprint actor.

64
00:04:09.900 --> 00:04:13.060
So you could duplicate that door and use it in many different places.

65
00:04:13.060 --> 00:04:17.660
You could even use it in different levels and that functionality would preserve and

66
00:04:17.660 --> 00:04:23.740
it would be housed inside of that actor rather than on the level blueprint.

67
00:04:23.740 --> 00:04:28.460
So a blueprint class is created and stored in the content browser and a blueprint actor

68
00:04:28.460 --> 00:04:32.020
is an instance of a blueprint class placed in the level.

69
00:04:32.020 --> 00:04:39.500
So you create all the functionality, you create the code inside of that blueprint and that

70
00:04:39.500 --> 00:04:44.600
houses inside of your content browser, which is your library of assets.

71
00:04:44.600 --> 00:04:48.840
And then when you drag and drop it into the scene, that has created an instance.

72
00:04:48.840 --> 00:04:55.400
So if you edit that door inside of the scene, it won't actually edit the main version of

73
00:04:55.400 --> 00:04:57.640
the content browser.

74
00:04:57.640 --> 00:05:02.020
If you want to make any global changes to that blueprint, you'd edit the content browser

75
00:05:02.020 --> 00:05:07.420
version and not the version that's placed in the level.

76
00:05:07.420 --> 00:05:14.140
So when we're thinking about common classes in blueprints, you want to be thinking about

77
00:05:14.140 --> 00:05:19.720
what is childhood and what type of framework you're trying to create with your blueprints.

78
00:05:19.720 --> 00:05:26.820
So if we take a basic framework here, which shows the hierarchy of common classes, the

79
00:05:26.820 --> 00:05:32.500
arrows indicate that the classes on the right is inheriting from the class on the left.

80
00:05:32.500 --> 00:05:36.200
So it's each one from objects.

81
00:05:36.200 --> 00:05:41.620
So if we take object on the left hand side, each one of them has been childhood from the

82
00:05:41.620 --> 00:05:42.620
object class.

83
00:05:42.620 --> 00:05:48.020
So object is at the top of the hierarchy and then you can create an actor based from an

84
00:05:48.020 --> 00:05:54.080
object and then just following the bottom flow, for example, a character.

85
00:05:54.080 --> 00:05:59.540
So on the bottom right is charted from the porn class, which is charted from an actor

86
00:05:59.540 --> 00:06:02.360
class, which then is charted from an object class.

87
00:06:02.360 --> 00:06:08.240
So the object is the end point of where the character would have been created from and

88
00:06:08.240 --> 00:06:14.680
then you can get more specified functionality as you go down the chain to get the character

89
00:06:14.680 --> 00:06:16.840
actor.

90
00:06:16.840 --> 00:06:21.080
When you're working with blueprints, you should have a basic understanding of these scripting

91
00:06:21.080 --> 00:06:22.080
terms.

92
00:06:22.080 --> 00:06:26.880
When we referred to before compiling your code, that's got some kind of compiler built into

93
00:06:26.880 --> 00:06:27.880
it.

94
00:06:27.880 --> 00:06:32.040
So when a blueprint script has been created, it needs to be compiled.

95
00:06:32.040 --> 00:06:35.880
Going back to those two buttons that I said you'd be using frequently, compile and save,

96
00:06:35.880 --> 00:06:37.320
compile and save.

97
00:06:37.320 --> 00:06:42.680
So compiling is a process of turning this source code, which in our example here is

98
00:06:42.680 --> 00:06:44.440
the visual scripting.

99
00:06:44.440 --> 00:06:48.480
So we want to turn the source code into the machine language that can be executed by the

100
00:06:48.480 --> 00:06:49.480
CPU.

101
00:06:49.480 --> 00:06:53.760
So compiling requires the change depending on the hardware and operating system and a

102
00:06:53.760 --> 00:07:00.960
compiler is the software used to compile source code written in a programming language.

103
00:07:00.960 --> 00:07:06.080
Blueprints are compiled to the bytecode level and processed by a virtual machine instead

104
00:07:06.080 --> 00:07:07.080
of the hardware.

105
00:07:07.080 --> 00:07:13.160
So a virtual machine is software that translates bytecode into instructions at the hardware

106
00:07:13.160 --> 00:07:17.600
you can understand and process and then you can also nativeize that code, which inside

107
00:07:17.600 --> 00:07:24.340
of Unreal if you ever need to nativeize blueprints, blueprints run slightly slower than C++ code.

108
00:07:24.340 --> 00:07:30.760
So if you really need to get maximum performance out of your production, you can actually

109
00:07:30.760 --> 00:07:36.800
convert blueprints to C++ by nativeizing these things.

110
00:07:36.800 --> 00:07:41.000
Blueprint interface is a collection of one or more functions that can be added to other

111
00:07:41.000 --> 00:07:46.440
blueprints and then blueprint interfaces allow different blueprints to share the data to

112
00:07:46.440 --> 00:07:47.480
send from one another.

113
00:07:47.480 --> 00:07:52.840
So before I was referencing this blueprint interface and talking about how you can get

114
00:07:52.840 --> 00:07:58.040
an interface, you can implement an interface on two different actors.

115
00:07:58.040 --> 00:08:05.080
Say you have a light switch on the wall and you have a door that you want to open, you

116
00:08:05.080 --> 00:08:10.440
can actually add an interface both to the light switch and the door and then that will

117
00:08:10.440 --> 00:08:12.180
create a communication channel.

118
00:08:12.180 --> 00:08:19.120
Say you want to get some kind of value from the switch and pass it over to the door, you

119
00:08:19.120 --> 00:08:21.200
can do that through the use of interfaces.

120
00:08:21.200 --> 00:08:26.880
So a blueprint interface is an asset that's created in the content browser and you can

121
00:08:27.120 --> 00:08:29.560
edit it in the Blueprint interface editor.

122
00:08:29.560 --> 00:08:34.840
So I'll just show you quickly how you go about creating an interface as well.

123
00:08:34.840 --> 00:08:38.800
So to create your Blueprint interface, again you probably want to organize your content

124
00:08:38.800 --> 00:08:44.240
and put it inside of a Blueprint folder or sometimes I even create a Blueprint interface

125
00:08:44.240 --> 00:08:49.720
folder so if I just right click BPI, so I give it a capital B, capital P and then lower

126
00:08:49.720 --> 00:08:51.640
case i for Blueprint interface.

127
00:08:51.640 --> 00:08:57.080
So again this is just a quick example but you just right click in the empty space, go

128
00:08:57.080 --> 00:09:01.840
to Blueprints and select your Blueprint interface and that's how you get to the interface window.
