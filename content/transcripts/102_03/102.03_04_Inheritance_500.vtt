WEBVTT

1
00:00:00.000 --> 00:00:08.460
Moving from interfaces into inheritance.

2
00:00:08.460 --> 00:00:13.920
So a child class inherits all the variables, components, functions, events of the parent

3
00:00:13.920 --> 00:00:14.920
class.

4
00:00:14.920 --> 00:00:20.480
So a child class can override the settings and functions of the parent and change fundamental

5
00:00:20.480 --> 00:00:21.480
behavior.

6
00:00:21.480 --> 00:00:26.800
So a child class can also implement new functionality in addition to what inherits from a parent

7
00:00:26.800 --> 00:00:27.800
class.

8
00:00:28.120 --> 00:00:30.080
Let's think about a parent class as a vehicle.

9
00:00:30.080 --> 00:00:34.960
So you've got a default template vehicle, it's just got a standard body shape, shall

10
00:00:34.960 --> 00:00:35.960
we say.

11
00:00:35.960 --> 00:00:37.320
It's got four wheels.

12
00:00:37.320 --> 00:00:43.520
You want some kind of driving functionality and you've housed all the default basic functionality

13
00:00:43.520 --> 00:00:47.160
of a vehicle and you can see that as a parent class.

14
00:00:47.160 --> 00:00:51.880
What you can do from here is you can right click on that blueprint, create a child class

15
00:00:51.880 --> 00:00:57.560
from that blueprint and then a new class will be created and it will house all of that

16
00:00:57.600 --> 00:00:59.160
parent functionality.

17
00:00:59.160 --> 00:01:06.040
But maybe now you want to add some car headlights or you want to create some additional behavior

18
00:01:06.040 --> 00:01:08.480
for this child class that wasn't in the parent class.

19
00:01:08.480 --> 00:01:10.600
So you can go ahead and do that.

20
00:01:10.600 --> 00:01:14.080
But now what if you want some additional functionality to this child?

21
00:01:14.080 --> 00:01:19.800
So you can create another child class of this child and maybe duplicate that three times

22
00:01:19.800 --> 00:01:25.000
and maybe now child A still has the headlights and it still has all the parent functionality

23
00:01:25.000 --> 00:01:27.080
but maybe you want to change the chassis now.

24
00:01:27.080 --> 00:01:31.000
Maybe you want to change the type of vehicle it is by changing the static mesh.

25
00:01:31.000 --> 00:01:34.320
You could change that on child A and it wouldn't change on child B.

26
00:01:34.320 --> 00:01:38.160
So you can maybe think of a different car type or a different body type on child B

27
00:01:38.160 --> 00:01:39.240
and it would still drive.

28
00:01:39.240 --> 00:01:42.280
It would still have all this parent functionality.

29
00:01:42.280 --> 00:01:46.560
It would still have its car headlights created in the child class but then you can then keep

30
00:01:46.560 --> 00:01:48.200
adding customized functionality.

31
00:01:48.200 --> 00:01:56.200
So whenever you find yourself creating maybe a type of interaction in a world or a certain

32
00:01:56.320 --> 00:02:03.320
thing that you might be using multiple times but then changing small bits of functionality

33
00:02:03.320 --> 00:02:08.160
on each one, it's a good practice to start thinking about housing something in a parent

34
00:02:08.160 --> 00:02:13.320
class and then creating child classes from that so that you can work efficiently.

35
00:02:13.320 --> 00:02:19.600
And also if a bug is in one for example, say you want to change the vehicle handling in

36
00:02:19.600 --> 00:02:26.160
this example, you can change it in the parent class and then that change would still migrate

37
00:02:26.320 --> 00:02:28.720
through to all the child classes as well.

38
00:02:28.720 --> 00:02:33.840
So instead of maybe if you had ended up with four different car types, instead of going

39
00:02:33.840 --> 00:02:38.720
in and changing each one four different times to fix this issue, you can just change it

40
00:02:38.720 --> 00:02:41.720
in the parent class and then that updates for everything else as well.

41
00:02:41.720 --> 00:02:44.960
So really powerful functionality.

42
00:02:44.960 --> 00:02:49.440
And then Unreal also uses inheritance in almost all aspects of design.

43
00:02:49.440 --> 00:02:53.800
So the actor class is a base class for all the objects that can be placed or spawned

44
00:02:53.800 --> 00:02:55.160
in the level.

45
00:02:55.160 --> 00:02:59.240
So lights, pawns, meshes are all child classes of the actor superclass.

46
00:02:59.240 --> 00:03:04.960
So going back to our example of the object before in previous slides, objects is the

47
00:03:04.960 --> 00:03:10.040
highest level in Unreal and then we go to actor and then say you're using point lights

48
00:03:10.040 --> 00:03:11.440
in your Unreal Engine scene.

49
00:03:11.440 --> 00:03:16.360
Well, a point light is inherited from a light class, which is inherited from an actor class,

50
00:03:16.360 --> 00:03:18.680
which is inherited from the object class.

51
00:03:18.680 --> 00:03:20.720
So you'll see this throughout Unreal.

52
00:03:20.720 --> 00:03:28.360
You can keep moving up through the inherited classes if you need that intended functionality.

53
00:03:28.360 --> 00:03:31.420
And then there's some additional resources on the documentation.

54
00:03:31.420 --> 00:03:36.620
So if you just look for Blueprint visual scripting in Unreal Engine, you'll be able to find many

55
00:03:36.620 --> 00:03:39.920
more resources there and these pages were put together by Sean.
