{
  "text": " Next, we should talk about the replication graph. This is a plugin that was introduced in 4.20 that offers a new network replication framework that deals with large numbers of players and replicated actors. We've seen how the default network replication system works, meaning that each actor must determine whether they should or shouldn't update to each client. This approach performs quite poorly when we have a large number of players or indeed a large number of replicated actors as the server must spend valuable CPU time performing these checks. This is where the replication graph comes in. It eliminates the need for individual actors to evaluate their own connection individually. This in turn solves a CPU bottleneck that we might otherwise get ourselves when dealing with large numbers of replicated actors. It's also important to note that we can make use of this new system alongside the standard system of network replication that we've just discussed. The replication graph is instead built up from nodes that individually perform the work that eliminate actors evaluating their own connections, but we're going to cover those in more detail soon. Lastly though, it is important to note that the replication graph system is entirely native and not exposed to Blueprint. Let's take a look at the key component of this framework that drives our functionality, that being the replication graph node. These nodes are responsible for building a list of actors to replicate to each client on demand. What's also great about these is that their work can be split across multiple frames as to not take a massive amount of CPU time. These nodes work great with persistent objects as it will reduce the time spent gathering their lists. Replication graph nodes are also very much a tool. They provide a simple framework for us programmers to leverage to meet our needs. With that in mind, we can make our nodes entirely game agnostic or completely game specific the power really is in the engineer's hands. We can utilize gameplay to drive which nodes a given actor may sit in, allowing for dynamic control of our replication. Lastly, nodes are also allowed to control how and when a group of actors are updated on the client. So with all this information now in mind, we can take a look at the visualization of what this might actually look like. Our replication graph will go through each node that we specify and begin to request a list of actors for each given connection from each node. We can see that we've got a node that will give us a list of actors that are always relevant. In the same theme, we can also define a list of always relevant actors for a specific team. We can also define nodes that return us all player states of the game. Lastly, we can also create nodes that break up their functionality with further nodes beneath them. In our example here with a spatialization node that breaks us up into two. One which will grab all dynamic actors in the area and one that will grab all of the static actors in the area. Both of these nodes will return their respective lists which will be collated together by the parent node. So let's say we've decided to use the replication graph as our choice of networking flow. How do we go about actually injecting our own replication graph? Well, Unreal provides two ways to do this. The first of which we can see here written in native code. We can bind to the replication graph's creation delegate and return our own replication graph through a lambda. The other way in which we can do this is through the default engine configuration file just as shown in the second image. It's worth noting that if we have a game with multiple game modes that have vastly different networking requirements, then the native implementation will serve your needs best.",
  "segments": [
    {
      "id": 0,
      "seek": 0,
      "start": 0.0,
      "end": 5.68,
      "text": " Next, we should talk about the replication graph. This is a plugin that was introduced",
      "tokens": [
        50364,
        3087,
        11,
        321,
        820,
        751,
        466,
        264,
        39911,
        4295,
        13,
        639,
        307,
        257,
        23407,
        300,
        390,
        7268,
        50648
      ],
      "temperature": 0.0,
      "avg_logprob": -0.08970525990361752,
      "compression_ratio": 1.7341269841269842,
      "no_speech_prob": 0.011327014304697514
    },
    {
      "id": 1,
      "seek": 0,
      "start": 5.68,
      "end": 11.040000000000001,
      "text": " in 4.20 that offers a new network replication framework that deals with large numbers of",
      "tokens": [
        50648,
        294,
        1017,
        13,
        2009,
        300,
        7736,
        257,
        777,
        3209,
        39911,
        8388,
        300,
        11215,
        365,
        2416,
        3547,
        295,
        50916
      ],
      "temperature": 0.0,
      "avg_logprob": -0.08970525990361752,
      "compression_ratio": 1.7341269841269842,
      "no_speech_prob": 0.011327014304697514
    },
    {
      "id": 2,
      "seek": 0,
      "start": 11.040000000000001,
      "end": 16.6,
      "text": " players and replicated actors. We've seen how the default network replication system",
      "tokens": [
        50916,
        4150,
        293,
        46365,
        10037,
        13,
        492,
        600,
        1612,
        577,
        264,
        7576,
        3209,
        39911,
        1185,
        51194
      ],
      "temperature": 0.0,
      "avg_logprob": -0.08970525990361752,
      "compression_ratio": 1.7341269841269842,
      "no_speech_prob": 0.011327014304697514
    },
    {
      "id": 3,
      "seek": 0,
      "start": 16.6,
      "end": 20.28,
      "text": " works, meaning that each actor must determine whether they should or shouldn't update to",
      "tokens": [
        51194,
        1985,
        11,
        3620,
        300,
        1184,
        8747,
        1633,
        6997,
        1968,
        436,
        820,
        420,
        4659,
        380,
        5623,
        281,
        51378
      ],
      "temperature": 0.0,
      "avg_logprob": -0.08970525990361752,
      "compression_ratio": 1.7341269841269842,
      "no_speech_prob": 0.011327014304697514
    },
    {
      "id": 4,
      "seek": 0,
      "start": 20.28,
      "end": 25.36,
      "text": " each client. This approach performs quite poorly when we have a large number of players",
      "tokens": [
        51378,
        1184,
        6423,
        13,
        639,
        3109,
        26213,
        1596,
        22271,
        562,
        321,
        362,
        257,
        2416,
        1230,
        295,
        4150,
        51632
      ],
      "temperature": 0.0,
      "avg_logprob": -0.08970525990361752,
      "compression_ratio": 1.7341269841269842,
      "no_speech_prob": 0.011327014304697514
    },
    {
      "id": 5,
      "seek": 2536,
      "start": 25.36,
      "end": 30.24,
      "text": " or indeed a large number of replicated actors as the server must spend valuable CPU time",
      "tokens": [
        50364,
        420,
        6451,
        257,
        2416,
        1230,
        295,
        46365,
        10037,
        382,
        264,
        7154,
        1633,
        3496,
        8263,
        13199,
        565,
        50608
      ],
      "temperature": 0.0,
      "avg_logprob": -0.108897218250093,
      "compression_ratio": 1.7964912280701755,
      "no_speech_prob": 0.3978971838951111
    },
    {
      "id": 6,
      "seek": 2536,
      "start": 30.24,
      "end": 35.56,
      "text": " performing these checks. This is where the replication graph comes in. It eliminates",
      "tokens": [
        50608,
        10205,
        613,
        13834,
        13,
        639,
        307,
        689,
        264,
        39911,
        4295,
        1487,
        294,
        13,
        467,
        49893,
        50874
      ],
      "temperature": 0.0,
      "avg_logprob": -0.108897218250093,
      "compression_ratio": 1.7964912280701755,
      "no_speech_prob": 0.3978971838951111
    },
    {
      "id": 7,
      "seek": 2536,
      "start": 35.56,
      "end": 40.44,
      "text": " the need for individual actors to evaluate their own connection individually. This in",
      "tokens": [
        50874,
        264,
        643,
        337,
        2609,
        10037,
        281,
        13059,
        641,
        1065,
        4984,
        16652,
        13,
        639,
        294,
        51118
      ],
      "temperature": 0.0,
      "avg_logprob": -0.108897218250093,
      "compression_ratio": 1.7964912280701755,
      "no_speech_prob": 0.3978971838951111
    },
    {
      "id": 8,
      "seek": 2536,
      "start": 40.44,
      "end": 44.28,
      "text": " turn solves a CPU bottleneck that we might otherwise get ourselves when dealing with",
      "tokens": [
        51118,
        1261,
        39890,
        257,
        13199,
        44641,
        547,
        300,
        321,
        1062,
        5911,
        483,
        4175,
        562,
        6260,
        365,
        51310
      ],
      "temperature": 0.0,
      "avg_logprob": -0.108897218250093,
      "compression_ratio": 1.7964912280701755,
      "no_speech_prob": 0.3978971838951111
    },
    {
      "id": 9,
      "seek": 2536,
      "start": 44.28,
      "end": 49.760000000000005,
      "text": " large numbers of replicated actors. It's also important to note that we can make use",
      "tokens": [
        51310,
        2416,
        3547,
        295,
        46365,
        10037,
        13,
        467,
        311,
        611,
        1021,
        281,
        3637,
        300,
        321,
        393,
        652,
        764,
        51584
      ],
      "temperature": 0.0,
      "avg_logprob": -0.108897218250093,
      "compression_ratio": 1.7964912280701755,
      "no_speech_prob": 0.3978971838951111
    },
    {
      "id": 10,
      "seek": 2536,
      "start": 49.760000000000005,
      "end": 53.96,
      "text": " of this new system alongside the standard system of network replication that we've",
      "tokens": [
        51584,
        295,
        341,
        777,
        1185,
        12385,
        264,
        3832,
        1185,
        295,
        3209,
        39911,
        300,
        321,
        600,
        51794
      ],
      "temperature": 0.0,
      "avg_logprob": -0.108897218250093,
      "compression_ratio": 1.7964912280701755,
      "no_speech_prob": 0.3978971838951111
    },
    {
      "id": 11,
      "seek": 5396,
      "start": 53.96,
      "end": 59.88,
      "text": " just discussed. The replication graph is instead built up from nodes that individually perform",
      "tokens": [
        50364,
        445,
        7152,
        13,
        440,
        39911,
        4295,
        307,
        2602,
        3094,
        493,
        490,
        13891,
        300,
        16652,
        2042,
        50660
      ],
      "temperature": 0.0,
      "avg_logprob": -0.1288160201041929,
      "compression_ratio": 1.6842105263157894,
      "no_speech_prob": 0.02029508166015148
    },
    {
      "id": 12,
      "seek": 5396,
      "start": 59.88,
      "end": 63.760000000000005,
      "text": " the work that eliminate actors evaluating their own connections, but we're going to",
      "tokens": [
        50660,
        264,
        589,
        300,
        13819,
        10037,
        27479,
        641,
        1065,
        9271,
        11,
        457,
        321,
        434,
        516,
        281,
        50854
      ],
      "temperature": 0.0,
      "avg_logprob": -0.1288160201041929,
      "compression_ratio": 1.6842105263157894,
      "no_speech_prob": 0.02029508166015148
    },
    {
      "id": 13,
      "seek": 5396,
      "start": 63.760000000000005,
      "end": 68.8,
      "text": " cover those in more detail soon. Lastly though, it is important to note that the replication",
      "tokens": [
        50854,
        2060,
        729,
        294,
        544,
        2607,
        2321,
        13,
        18072,
        1673,
        11,
        309,
        307,
        1021,
        281,
        3637,
        300,
        264,
        39911,
        51106
      ],
      "temperature": 0.0,
      "avg_logprob": -0.1288160201041929,
      "compression_ratio": 1.6842105263157894,
      "no_speech_prob": 0.02029508166015148
    },
    {
      "id": 14,
      "seek": 5396,
      "start": 68.8,
      "end": 74.96000000000001,
      "text": " graph system is entirely native and not exposed to Blueprint. Let's take a look at the key",
      "tokens": [
        51106,
        4295,
        1185,
        307,
        7696,
        8470,
        293,
        406,
        9495,
        281,
        2177,
        29017,
        13,
        961,
        311,
        747,
        257,
        574,
        412,
        264,
        2141,
        51414
      ],
      "temperature": 0.0,
      "avg_logprob": -0.1288160201041929,
      "compression_ratio": 1.6842105263157894,
      "no_speech_prob": 0.02029508166015148
    },
    {
      "id": 15,
      "seek": 5396,
      "start": 74.96000000000001,
      "end": 78.56,
      "text": " component of this framework that drives our functionality, that being the replication",
      "tokens": [
        51414,
        6542,
        295,
        341,
        8388,
        300,
        11754,
        527,
        14980,
        11,
        300,
        885,
        264,
        39911,
        51594
      ],
      "temperature": 0.0,
      "avg_logprob": -0.1288160201041929,
      "compression_ratio": 1.6842105263157894,
      "no_speech_prob": 0.02029508166015148
    },
    {
      "id": 16,
      "seek": 7856,
      "start": 79.56,
      "end": 83.56,
      "text": " graph node. These nodes are responsible for building a list of actors to replicate to",
      "tokens": [
        50414,
        4295,
        9984,
        13,
        1981,
        13891,
        366,
        6250,
        337,
        2390,
        257,
        1329,
        295,
        10037,
        281,
        25356,
        281,
        50614
      ],
      "temperature": 0.0,
      "avg_logprob": -0.11222725470089218,
      "compression_ratio": 1.7169117647058822,
      "no_speech_prob": 0.6356155276298523
    },
    {
      "id": 17,
      "seek": 7856,
      "start": 83.56,
      "end": 88.60000000000001,
      "text": " each client on demand. What's also great about these is that their work can be split across",
      "tokens": [
        50614,
        1184,
        6423,
        322,
        4733,
        13,
        708,
        311,
        611,
        869,
        466,
        613,
        307,
        300,
        641,
        589,
        393,
        312,
        7472,
        2108,
        50866
      ],
      "temperature": 0.0,
      "avg_logprob": -0.11222725470089218,
      "compression_ratio": 1.7169117647058822,
      "no_speech_prob": 0.6356155276298523
    },
    {
      "id": 18,
      "seek": 7856,
      "start": 88.60000000000001,
      "end": 95.16,
      "text": " multiple frames as to not take a massive amount of CPU time. These nodes work great with persistent",
      "tokens": [
        50866,
        3866,
        12083,
        382,
        281,
        406,
        747,
        257,
        5994,
        2372,
        295,
        13199,
        565,
        13,
        1981,
        13891,
        589,
        869,
        365,
        24315,
        51194
      ],
      "temperature": 0.0,
      "avg_logprob": -0.11222725470089218,
      "compression_ratio": 1.7169117647058822,
      "no_speech_prob": 0.6356155276298523
    },
    {
      "id": 19,
      "seek": 7856,
      "start": 95.16,
      "end": 100.48,
      "text": " objects as it will reduce the time spent gathering their lists. Replication graph nodes are also",
      "tokens": [
        51194,
        6565,
        382,
        309,
        486,
        5407,
        264,
        565,
        4418,
        13519,
        641,
        14511,
        13,
        1300,
        4770,
        399,
        4295,
        13891,
        366,
        611,
        51460
      ],
      "temperature": 0.0,
      "avg_logprob": -0.11222725470089218,
      "compression_ratio": 1.7169117647058822,
      "no_speech_prob": 0.6356155276298523
    },
    {
      "id": 20,
      "seek": 7856,
      "start": 100.48,
      "end": 104.72,
      "text": " very much a tool. They provide a simple framework for us programmers to leverage to meet our",
      "tokens": [
        51460,
        588,
        709,
        257,
        2290,
        13,
        814,
        2893,
        257,
        2199,
        8388,
        337,
        505,
        41504,
        281,
        13982,
        281,
        1677,
        527,
        51672
      ],
      "temperature": 0.0,
      "avg_logprob": -0.11222725470089218,
      "compression_ratio": 1.7169117647058822,
      "no_speech_prob": 0.6356155276298523
    },
    {
      "id": 21,
      "seek": 10472,
      "start": 104.72,
      "end": 110.72,
      "text": " needs. With that in mind, we can make our nodes entirely game agnostic or completely game specific",
      "tokens": [
        50364,
        2203,
        13,
        2022,
        300,
        294,
        1575,
        11,
        321,
        393,
        652,
        527,
        13891,
        7696,
        1216,
        623,
        77,
        19634,
        420,
        2584,
        1216,
        2685,
        50664
      ],
      "temperature": 0.0,
      "avg_logprob": -0.13055623316131862,
      "compression_ratio": 1.7243816254416962,
      "no_speech_prob": 0.05328623950481415
    },
    {
      "id": 22,
      "seek": 10472,
      "start": 110.72,
      "end": 116.08,
      "text": " the power really is in the engineer's hands. We can utilize gameplay to drive which nodes a given",
      "tokens": [
        50664,
        264,
        1347,
        534,
        307,
        294,
        264,
        11403,
        311,
        2377,
        13,
        492,
        393,
        16117,
        11421,
        281,
        3332,
        597,
        13891,
        257,
        2212,
        50932
      ],
      "temperature": 0.0,
      "avg_logprob": -0.13055623316131862,
      "compression_ratio": 1.7243816254416962,
      "no_speech_prob": 0.05328623950481415
    },
    {
      "id": 23,
      "seek": 10472,
      "start": 116.08,
      "end": 122.56,
      "text": " actor may sit in, allowing for dynamic control of our replication. Lastly, nodes are also allowed",
      "tokens": [
        50932,
        8747,
        815,
        1394,
        294,
        11,
        8293,
        337,
        8546,
        1969,
        295,
        527,
        39911,
        13,
        18072,
        11,
        13891,
        366,
        611,
        4350,
        51256
      ],
      "temperature": 0.0,
      "avg_logprob": -0.13055623316131862,
      "compression_ratio": 1.7243816254416962,
      "no_speech_prob": 0.05328623950481415
    },
    {
      "id": 24,
      "seek": 10472,
      "start": 122.56,
      "end": 129.52,
      "text": " to control how and when a group of actors are updated on the client. So with all this information",
      "tokens": [
        51256,
        281,
        1969,
        577,
        293,
        562,
        257,
        1594,
        295,
        10037,
        366,
        10588,
        322,
        264,
        6423,
        13,
        407,
        365,
        439,
        341,
        1589,
        51604
      ],
      "temperature": 0.0,
      "avg_logprob": -0.13055623316131862,
      "compression_ratio": 1.7243816254416962,
      "no_speech_prob": 0.05328623950481415
    },
    {
      "id": 25,
      "seek": 10472,
      "start": 129.52,
      "end": 134.16,
      "text": " now in mind, we can take a look at the visualization of what this might actually look like. Our",
      "tokens": [
        51604,
        586,
        294,
        1575,
        11,
        321,
        393,
        747,
        257,
        574,
        412,
        264,
        25801,
        295,
        437,
        341,
        1062,
        767,
        574,
        411,
        13,
        2621,
        51836
      ],
      "temperature": 0.0,
      "avg_logprob": -0.13055623316131862,
      "compression_ratio": 1.7243816254416962,
      "no_speech_prob": 0.05328623950481415
    },
    {
      "id": 26,
      "seek": 13416,
      "start": 134.16,
      "end": 138.72,
      "text": " replication graph will go through each node that we specify and begin to request a list of actors",
      "tokens": [
        50364,
        39911,
        4295,
        486,
        352,
        807,
        1184,
        9984,
        300,
        321,
        16500,
        293,
        1841,
        281,
        5308,
        257,
        1329,
        295,
        10037,
        50592
      ],
      "temperature": 0.0,
      "avg_logprob": -0.07610562417359479,
      "compression_ratio": 1.952755905511811,
      "no_speech_prob": 0.004196117166429758
    },
    {
      "id": 27,
      "seek": 13416,
      "start": 138.72,
      "end": 143.51999999999998,
      "text": " for each given connection from each node. We can see that we've got a node that will give us a list",
      "tokens": [
        50592,
        337,
        1184,
        2212,
        4984,
        490,
        1184,
        9984,
        13,
        492,
        393,
        536,
        300,
        321,
        600,
        658,
        257,
        9984,
        300,
        486,
        976,
        505,
        257,
        1329,
        50832
      ],
      "temperature": 0.0,
      "avg_logprob": -0.07610562417359479,
      "compression_ratio": 1.952755905511811,
      "no_speech_prob": 0.004196117166429758
    },
    {
      "id": 28,
      "seek": 13416,
      "start": 143.51999999999998,
      "end": 148.56,
      "text": " of actors that are always relevant. In the same theme, we can also define a list of always relevant",
      "tokens": [
        50832,
        295,
        10037,
        300,
        366,
        1009,
        7340,
        13,
        682,
        264,
        912,
        6314,
        11,
        321,
        393,
        611,
        6964,
        257,
        1329,
        295,
        1009,
        7340,
        51084
      ],
      "temperature": 0.0,
      "avg_logprob": -0.07610562417359479,
      "compression_ratio": 1.952755905511811,
      "no_speech_prob": 0.004196117166429758
    },
    {
      "id": 29,
      "seek": 13416,
      "start": 148.56,
      "end": 154.88,
      "text": " actors for a specific team. We can also define nodes that return us all player states of the game.",
      "tokens": [
        51084,
        10037,
        337,
        257,
        2685,
        1469,
        13,
        492,
        393,
        611,
        6964,
        13891,
        300,
        2736,
        505,
        439,
        4256,
        4368,
        295,
        264,
        1216,
        13,
        51400
      ],
      "temperature": 0.0,
      "avg_logprob": -0.07610562417359479,
      "compression_ratio": 1.952755905511811,
      "no_speech_prob": 0.004196117166429758
    },
    {
      "id": 30,
      "seek": 13416,
      "start": 155.84,
      "end": 160.56,
      "text": " Lastly, we can also create nodes that break up their functionality with further nodes beneath them.",
      "tokens": [
        51448,
        18072,
        11,
        321,
        393,
        611,
        1884,
        13891,
        300,
        1821,
        493,
        641,
        14980,
        365,
        3052,
        13891,
        17149,
        552,
        13,
        51684
      ],
      "temperature": 0.0,
      "avg_logprob": -0.07610562417359479,
      "compression_ratio": 1.952755905511811,
      "no_speech_prob": 0.004196117166429758
    },
    {
      "id": 31,
      "seek": 16056,
      "start": 160.72,
      "end": 165.92000000000002,
      "text": " In our example here with a spatialization node that breaks us up into two. One which will grab",
      "tokens": [
        50372,
        682,
        527,
        1365,
        510,
        365,
        257,
        23598,
        2144,
        9984,
        300,
        9857,
        505,
        493,
        666,
        732,
        13,
        1485,
        597,
        486,
        4444,
        50632
      ],
      "temperature": 0.0,
      "avg_logprob": -0.12882935784079813,
      "compression_ratio": 1.7168458781362008,
      "no_speech_prob": 0.020323023200035095
    },
    {
      "id": 32,
      "seek": 16056,
      "start": 165.92000000000002,
      "end": 170.96,
      "text": " all dynamic actors in the area and one that will grab all of the static actors in the area. Both",
      "tokens": [
        50632,
        439,
        8546,
        10037,
        294,
        264,
        1859,
        293,
        472,
        300,
        486,
        4444,
        439,
        295,
        264,
        13437,
        10037,
        294,
        264,
        1859,
        13,
        6767,
        50884
      ],
      "temperature": 0.0,
      "avg_logprob": -0.12882935784079813,
      "compression_ratio": 1.7168458781362008,
      "no_speech_prob": 0.020323023200035095
    },
    {
      "id": 33,
      "seek": 16056,
      "start": 170.96,
      "end": 175.36,
      "text": " of these nodes will return their respective lists which will be collated together by the parent node.",
      "tokens": [
        50884,
        295,
        613,
        13891,
        486,
        2736,
        641,
        23649,
        14511,
        597,
        486,
        312,
        1263,
        770,
        1214,
        538,
        264,
        2596,
        9984,
        13,
        51104
      ],
      "temperature": 0.0,
      "avg_logprob": -0.12882935784079813,
      "compression_ratio": 1.7168458781362008,
      "no_speech_prob": 0.020323023200035095
    },
    {
      "id": 34,
      "seek": 16056,
      "start": 176.88,
      "end": 181.12,
      "text": " So let's say we've decided to use the replication graph as our choice of networking flow.",
      "tokens": [
        51180,
        407,
        718,
        311,
        584,
        321,
        600,
        3047,
        281,
        764,
        264,
        39911,
        4295,
        382,
        527,
        3922,
        295,
        17985,
        3095,
        13,
        51392
      ],
      "temperature": 0.0,
      "avg_logprob": -0.12882935784079813,
      "compression_ratio": 1.7168458781362008,
      "no_speech_prob": 0.020323023200035095
    },
    {
      "id": 35,
      "seek": 16056,
      "start": 181.12,
      "end": 186.24,
      "text": " How do we go about actually injecting our own replication graph? Well, Unreal provides two ways",
      "tokens": [
        51392,
        1012,
        360,
        321,
        352,
        466,
        767,
        10711,
        278,
        527,
        1065,
        39911,
        4295,
        30,
        1042,
        11,
        34464,
        6417,
        732,
        2098,
        51648
      ],
      "temperature": 0.0,
      "avg_logprob": -0.12882935784079813,
      "compression_ratio": 1.7168458781362008,
      "no_speech_prob": 0.020323023200035095
    },
    {
      "id": 36,
      "seek": 18624,
      "start": 186.24,
      "end": 191.44,
      "text": " to do this. The first of which we can see here written in native code. We can bind to the",
      "tokens": [
        50364,
        281,
        360,
        341,
        13,
        440,
        700,
        295,
        597,
        321,
        393,
        536,
        510,
        3720,
        294,
        8470,
        3089,
        13,
        492,
        393,
        14786,
        281,
        264,
        50624
      ],
      "temperature": 0.0,
      "avg_logprob": -0.08159443911384134,
      "compression_ratio": 1.73992673992674,
      "no_speech_prob": 0.011677426286041737
    },
    {
      "id": 37,
      "seek": 18624,
      "start": 191.44,
      "end": 196.16,
      "text": " replication graph's creation delegate and return our own replication graph through a lambda.",
      "tokens": [
        50624,
        39911,
        4295,
        311,
        8016,
        40999,
        293,
        2736,
        527,
        1065,
        39911,
        4295,
        807,
        257,
        13607,
        13,
        50860
      ],
      "temperature": 0.0,
      "avg_logprob": -0.08159443911384134,
      "compression_ratio": 1.73992673992674,
      "no_speech_prob": 0.011677426286041737
    },
    {
      "id": 38,
      "seek": 18624,
      "start": 197.04000000000002,
      "end": 201.20000000000002,
      "text": " The other way in which we can do this is through the default engine configuration file just as",
      "tokens": [
        50904,
        440,
        661,
        636,
        294,
        597,
        321,
        393,
        360,
        341,
        307,
        807,
        264,
        7576,
        2848,
        11694,
        3991,
        445,
        382,
        51112
      ],
      "temperature": 0.0,
      "avg_logprob": -0.08159443911384134,
      "compression_ratio": 1.73992673992674,
      "no_speech_prob": 0.011677426286041737
    },
    {
      "id": 39,
      "seek": 18624,
      "start": 201.20000000000002,
      "end": 206.48000000000002,
      "text": " shown in the second image. It's worth noting that if we have a game with multiple game modes that",
      "tokens": [
        51112,
        4898,
        294,
        264,
        1150,
        3256,
        13,
        467,
        311,
        3163,
        26801,
        300,
        498,
        321,
        362,
        257,
        1216,
        365,
        3866,
        1216,
        14068,
        300,
        51376
      ],
      "temperature": 0.0,
      "avg_logprob": -0.08159443911384134,
      "compression_ratio": 1.73992673992674,
      "no_speech_prob": 0.011677426286041737
    },
    {
      "id": 40,
      "seek": 18624,
      "start": 206.48000000000002,
      "end": 211.84,
      "text": " have vastly different networking requirements, then the native implementation will serve your needs",
      "tokens": [
        51376,
        362,
        41426,
        819,
        17985,
        7728,
        11,
        550,
        264,
        8470,
        11420,
        486,
        4596,
        428,
        2203,
        51644
      ],
      "temperature": 0.0,
      "avg_logprob": -0.08159443911384134,
      "compression_ratio": 1.73992673992674,
      "no_speech_prob": 0.011677426286041737
    },
    {
      "id": 41,
      "seek": 21184,
      "start": 211.84,
      "end": 219.44,
      "text": " best.",
      "tokens": [
        50364,
        1151,
        13,
        50744
      ],
      "temperature": 0.0,
      "avg_logprob": -0.6735246181488037,
      "compression_ratio": 0.38461538461538464,
      "no_speech_prob": 0.4800258278846741
    }
  ],
  "language": "en"
}